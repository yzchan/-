# 内中断

本章主要介绍了什么是内中断、内中断的类型以及内中断的执行过程。最后几章都是围绕实验12的编写自己的int0中断处理程序展开的。

中断是什么？其实在生活很常见：比如我们正在工作，老板突然打电话过来让打印一份报告。于是我们停下手里的工作，先去打印好报告交给老板，然后回来接着工作。这其实就是一个典型的中断过程，CPU的中断过程也是差不多的。

我们不知道老板什么时候突然会有新的指示，计算机也是一样，不知道你下一次时候点鼠标，什么时候敲键盘。很早的计算机都是没有这种能力的，那时候大家应该听说过穿孔纸带，其实就是01指令，输入计算机后就是从前往后执行，不能暂停，更无法调试。所以我们想给计算机也赋予类似的中断能力。

在这个过程中有个点是要注意的：我们取打印报告可能直接就去了。打完好回来再努力回想刚才的工作做到哪里了，然后接着工作。可是计算机或者说CPU是不行的，CPU不会回想，只能利用逻辑电路做做简单的运算，用寄存器和内存存储一些中间结果。所以想让计算机有中断功能必须有以下几个必要的功能：

- 检测中断能力：CPU每次执行下一条指令之前都去固定的地方看看有没有中断信息，有就跳过去处理中断，没有就接着执行下一条指令。
- 保存现场和恢复现场：检测到中断信息之后，需要把当前程序执行到哪里记录下来，当然还包括当前用到的寄存器信息。处理完中断之后回来还需要恢复现场

有了这些之后，我们似乎可以给计算机赋予中断能力了。再细化一下：
如何检测中断，在寄存器标志位中找两个位置表示是否有中断，cpu每次执行指令都读一下标志位。这两个标志寄存器就是TF/IF
如何保存现场和跳转，CPU是根据程序计数器cs:ip执行下一条指令的，所以中断的跳转很简单，把cs:ip指向新的中断处理程序就好。怎么跳回来呢？当时把当前的cs:ip先保存下来，再设置新的cs:ip。另外不要忘了寄存器的状态也是和指令息息相关的，在跳转之前也要保存下来。保存现场用3个指令描述一下就是 push ip; push cs; pushf。然后设置cs=?;ip=?。

那么问题又来了。 程序计数器cs:ip到底设置到哪里呢？肯定中断处理程序的入口地址处。但是这个入口地址又在哪里？答案就是中断向量表了。具体方案就不再叙述，书上讲的很清楚。把这些理清楚。最后的实验12就很好理解了。

最后中断处理程序执行完成之后恢复现场再跳回来。用指令描述一下过程：pop ip; pop cs; popf; 。汇编还提供了一条iret指令完成前面3条指令一样的功能。

> 内中断就是CPU内部产生的中断，有内中断，当然也有外中断。外中断在15章，一般是外设给CPU发的中断信息，比如上面说的键盘被敲下去了，键盘里的芯片就会给CPU发一条中断信息，让CPU去处理。

所以中断的本质其实还是转移。


内中断类型
 - 1、除法错误：0号中断
 - 2、单步执行：1号中断
 - 3、执行into指令：4号中断
 - 4、执行int指令：int n;表示n号中断

### 中断处理程序
又称中断例程，也是一段指令集合，在触发中断后，cpu设置程序计数器cs:ip指向中断例程的入口地址开始执行中断例程。
cpu如何知道中断例程的入口地址呢？肯定需要一段内存存放这些地址，这就是中断向量表。

### 中断向量表
存放所有中断例程的入口地址，在8086CPU中，中断向量表存放在0000:0000~0000:03FF这1024个地址空间中，每个表项占用4个字节，其中高2位存cs段地址，低2位存ip偏移地址：[ip,cs]。可以算出8086CPU上最多可以存放256个中断信息。

### 12.4 中断过程
中断过程是由硬件来完成的（过程是连续且不可被打断的，无法被程序员修改的）。
中断过程本质就是跳转，但是跳转之前需要先保存现场，以备后面再跳回来继续执行。中断过程：
 - 1、取得中断类型码N
 - 2、pushf TF=0 IF=0 push cs,push ip （保存现场）
 - 3、ip=n*4  cs=n*4+2 （设置跳转地址）

>TF:调试标志位。当TF=1时，处理器每次只执行一条指令，即单步执行;
>IF:中断允许标志位。它用来控制8086是否允许接收外部中断请求。若IF=1，8086能响应外部中断，反之则屏蔽外部中断;


### 中断处理程序和iret指令
中断例程的常规步骤
 - 1、保存用的的寄存器
 - 2、处理中断
 - 3、恢复用到的寄存器
 - 4、用iret返回

