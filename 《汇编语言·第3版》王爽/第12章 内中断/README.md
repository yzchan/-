# 内中断

本章主要介绍了什么是内中断、内中断的类型以及内中断的执行过程。最后几章都是围绕实验12的编写自己的int0中断处理程序展开的。

中断是什么？其实在生活很常见：比如我们正在工作，老板突然打电话过来让打印一份报告。于是我们停下手里的工作，先去打印好报告交给老板，然后回来接着工作。这其实就是一个典型的中断过程，CPU的中断过程也是差不多的。

我们不知道老板什么时候突然会有新的指示，计算机也是一样，不知道你下一次时候点鼠标，什么时候敲键盘。很早的计算机都是没有这种能力的，那时候大家应该听说过穿孔纸带，其实就是01指令，输入计算机后就是从前往后执行，不能暂停，更无法调试。所以我们想给计算机也赋予类似的中断能力。

在这个过程中有个点是要注意的：我们取打印报告可能直接就去了。打完好回来再努力回想刚才的工作做到哪里了，然后接着工作。可是计算机或者说CPU是不行的，CPU不会回想，只能利用逻辑电路做做简单的运算，用寄存器和内存存储一些中间结果。所以想让计算机有中断功能必须有以下几个必要的功能：

- 检测中断能力：CPU每次执行下一条指令之前都去固定的地方看看有没有中断信息，有就跳过去处理中断，没有就接着执行下一条指令。
- 保存现场和恢复现场：检测到中断信息之后，需要把当前程序执行到哪里记录下来，当然还包括当前用到的寄存器信息。处理完中断之后回来还需要恢复现场

有了这些之后，我们似乎可以给计算机赋予中断能力了。再细化一下：
如何检测中断，在寄存器标志位中找两个位置表示是否有中断，cpu每次执行指令都读一下标志位。这两个标志寄存器就是TF/IF
如何保存现场和跳转，CPU是根据程序计数器cs:ip执行下一条指令的，所以中断的跳转很简单，把cs:ip指向新的中断处理程序就好。怎么跳回来呢？当时把当前的cs:ip先保存下来，再设置新的cs:ip。另外不要忘了寄存器的状态也是和指令息息相关的，在跳转之前也要保存下来。保存现场用3个指令描述一下就是 push ip; push cs; pushf。然后设置cs=?;ip=?。

那么问题又来了。 程序计数器cs:ip到底设置到哪里呢？肯定中断处理程序的入口地址处。但是这个入口地址又在哪里？答案就是中断向量表了。具体方案就不再叙述，书上讲的很清楚。把这些理清楚。最后的实验12就很好理解了。

最后中断处理程序执行完成之后恢复现场再跳回来。用指令描述一下过程：pop ip; pop cs; popf; 。汇编还提供了一条iret指令完成前面3条指令一样的功能。

> 内中断就是CPU内部产生的中断，有内中断，当然也有外中断。外中断在15章，一般是外设给CPU发的中断信息，比如上面说的键盘被敲下去了，键盘里的芯片就会给CPU发一条中断信息，让CPU去处理。

所以中断的本质其实还是转移。


### 分节重点：

### 12.1 内中断的产生
内中断类型
 - 1、除法错误：0号中断
 - 2、单步执行：1号中断
 - 3、执行into指令：4号中断
 - 4、执行int指令：int n;表示n号中断


### 12.2 中断处理程序
又称中断例程，也是一段指令集合，在触发中断后，cpu设置程序计数器cs:ip指向中断例程的入口地址开始执行中断例程。
cpu如何知道中断例程的入口地址呢？肯定需要一段内存存放这些地址，这就是中断向量表。

### 12.3 中断向量表
存放所有中断例程的入口地址，在8086CPU中，中断向量表存放在0000:0000~0000:03FF这1024个地址空间中，每个表项占用4个字节，其中高2位存cs段地址，低2位存ip偏移地址：[ip,cs]。可以算出8086CPU上最多可以存放256个中断信息。

### 12.4 中断过程
中断过程是由硬件来完成的（过程是连续且不可被打断的，无法被程序员修改的）。
中断过程本质就是跳转，但是跳转之前需要先保存现场，以备后面再跳回来继续执行。中断过程：
 - 1、取得中断类型码N
 - 2、pushf TF=0 IF=0 push cs,push ip （保存现场）
 - 3、ip=n*4  cs=n*4+2 （设置跳转地址）


### 12.5 中断处理程序和iret指令
中断例程的常规步骤
 - 1、保存用的的寄存器
 - 2、处理中断
 - 3、恢复用到的寄存器
 - 4、用iret返回


### 12.6 除法错误中断的处理
从12.6~12.10其实都是为最后的实验12服务的。
```s
mov ax,1000h
mov bh,1
div bh
```
本节需要注意的是，再dosbox中执行上述有除法溢出的指令并不能看到书上显示的Divide overflow提示。网上搜索了一下，发现也有不少人遇到同样的问题，有说是dosbox无法触发0号中断的，也有说是dosbox实现机制问题的。
不过经过debug跟踪发现，dosbox是可以正确触发0号中断，并从中断向量表中读取到正确的cs:ip的，只是dosbox的0号中断处理程序好像有问题，不能正确执行。
那既然是中断例程有问题，而后面的课程又恰好是编写自己实现的0号中断例程，那我们是不是注册好自己的0号中断例程，然后调用就可以了呢？
经过试验发现确实如此。我们把试验12的0号中断例程生成1.exe文件，再把上述触发除法溢出的代码也生成2.exe文件，打开dosbox，先执行1.exe注册安装我们自己的0号中断例程，在不关闭dosbox的情况下继续执行2.exe，发现也是可以正确触发0号中断的。当然关闭dosbox直接执行2.exe就没有任何响应。

所以猜测是dosbox可能存在bug没有正确安装好0号中断例程或者确实是因为实现机制导致的这个问题，但是dosbox肯定是可以正确触发0号中断的。

### 12.7 编程处理0号中断

### 12.8 安装

### 12.9 do0程序

### 12.10 设置向量表

### 12.11 单步中断
debug就是依靠1号单步中断来实现的。单步中断为单步跟踪程序的执行过程提供了实现机制

### 12.12 响应中断的特殊情况
有些汇编指令必须连续执行，如果中间被中断程序打断可能会造成意想不到的后果。所以CPU会将这些必须连续执行的指令都执行结束再去响应中断。比如以下代码连续设置cs栈段和ip栈顶指针的连续指令
```s
mov ax,1000h
mov ss,ax
mov sp,0
```

### 实验12 编写0号中断的处理程序
程序整体流程：
编写0号中断例程 -> 将中断例程拷贝到指定内存空间 -> 将内存空间地址注册到中断向量表 -> 触发0号中断 -> 程序返回
详见代码